#!/usr/bin/env python3
"""
Figure 15: Observer Operation Switching Process
Show how observers dynamically switch between φ, e, π operations
"""

import numpy as np
import matplotlib.pyplot as plt
from recursive_math_functions import recursive_math

plt.style.use('default')
plt.rcParams['font.size'] = 11

def generate_figure_15():
    """Generate single figure: Operation Switching"""
    
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
    
    # Define operation sequence for one observer
    operation_sequence = ['φ']*6 + ['e']*8 + ['π']*5 + ['φ','e','π']*2  # 25 total steps
    
    # Top left: Operation timeline
    colors_map = {'φ': 'gold', 'e': 'green', 'π': 'purple'}
    colors = [colors_map[op] for op in operation_sequence]
    
    ax1.bar(range(len(operation_sequence)), [1]*len(operation_sequence), 
           color=colors, alpha=0.8, edgecolor='black', linewidth=0.5)
    
    # Mark transition points
    transitions = [6, 14, 19]  # Where operations change
    for trans in transitions:
        ax1.axvline(x=trans, color='red', linestyle='--', linewidth=2, alpha=0.8)
    
    ax1.set_xlabel('Time Step')
    ax1.set_ylabel('Operation Type')
    ax1.set_title('Observer Operation Timeline\n(φ → e → π → mixed)')
    ax1.set_ylim(0, 1.2)
    
    # Top right: Data generated by switching operations
    generated_data = []
    
    for i, operation in enumerate(operation_sequence):
        if operation == 'φ':
            # Use Fibonacci if we have enough previous data for recursion
            if i >= 2 and generated_data[i-1] != 0 and generated_data[i-2] != 0:
                data_value = generated_data[i-1] + generated_data[i-2]
            else:
                data_value = 1  # Initial Fibonacci value
        elif operation == 'e':
            # Use factorial pattern
            step_in_e_phase = sum(1 for j in range(i) if operation_sequence[j] == 'e')
            data_value = 10 / (step_in_e_phase + 1)  # Simplified factorial decay
        else:  # π operation
            step_in_pi_phase = sum(1 for j in range(i) if operation_sequence[j] == 'π')
            data_value = 5 * (-1)**step_in_pi_phase / (2*step_in_pi_phase + 1)
        
        generated_data.append(data_value)
    
    # Plot generated data with operation coloring
    ax2.plot(range(len(generated_data)), generated_data, 'k-', linewidth=2, alpha=0.7)
    
    # Color segments by operation
    for i in range(len(generated_data)-1):
        color = colors_map[operation_sequence[i]]
        ax2.plot([i, i+1], [generated_data[i], generated_data[i+1]], 
                color=color, linewidth=4, alpha=0.8)
    
    ax2.set_xlabel('Time Step')
    ax2.set_ylabel('Generated Data')
    ax2.set_title('Data from Operation Switching\n(Different patterns)')
    ax2.grid(True, alpha=0.3)
    
    # Bottom left: Trajectory in space (operation switching effects)
    trajectory_x = [1]  # Starting position
    trajectory_y = [1]
    
    for i, (operation, data) in enumerate(zip(operation_sequence, generated_data)):
        if operation == 'φ':
            # Growth direction
            next_x = trajectory_x[-1] + 0.1 * np.cos(i * 0.3) * (1 + i*0.05)
            next_y = trajectory_y[-1] + 0.1 * np.sin(i * 0.3) * (1 + i*0.05)
        elif operation == 'e':
            # Converging direction
            next_x = trajectory_x[-1] + 0.05 * np.cos(i * 0.4)
            next_y = trajectory_y[-1] + 0.05 * np.sin(i * 0.4)
        else:  # π operation
            # Oscillating direction
            next_x = trajectory_x[-1] + 0.08 * np.cos(i * 0.8) * (-1)**i
            next_y = trajectory_y[-1] + 0.08 * np.sin(i * 0.8) * (-1)**i
        
        trajectory_x.append(next_x)
        trajectory_y.append(next_y)
    
    # Remove initial position from trajectory
    trajectory_x = trajectory_x[1:]
    trajectory_y = trajectory_y[1:]
    
    # Plot trajectory with operation coloring
    ax3.set_aspect('equal')
    
    for i in range(len(trajectory_x)-1):
        color = colors_map[operation_sequence[i]]
        ax3.plot([trajectory_x[i], trajectory_x[i+1]], 
                [trajectory_y[i], trajectory_y[i+1]],
                color=color, linewidth=3, alpha=0.8)
    
    # Mark start and current position
    ax3.plot(trajectory_x[0], trajectory_y[0], 'go', markersize=12,
            markeredgecolor='black', markeredgewidth=2)
    ax3.plot(trajectory_x[-1], trajectory_y[-1], 'ro', markersize=12,
            markeredgecolor='black', markeredgewidth=2)
    
    ax3.set_xlabel('Spatial X Coordinate')
    ax3.set_ylabel('Spatial Y Coordinate')
    ax3.set_title('Observer Spatial Trajectory\n(Operation switching effects)')
    ax3.grid(True, alpha=0.3)
    
    # Bottom right: Operation switching statistics
    # Count operation usage
    phi_count = operation_sequence.count('φ')
    e_count = operation_sequence.count('e')
    pi_count = operation_sequence.count('π')
    
    operations = ['φ-mode', 'e-mode', 'π-mode']
    counts = [phi_count, e_count, pi_count]
    colors = ['gold', 'green', 'purple']
    
    bars = ax4.bar(operations, counts, color=colors, alpha=0.7,
                  edgecolor='black', linewidth=2)
    
    # Add count labels
    for bar, count in zip(bars, counts):
        height = bar.get_height()
        ax4.text(bar.get_x() + bar.get_width()/2., height + 0.1,
                str(count), ha='center', va='bottom', fontsize=12, weight='bold')
    
    ax4.set_ylabel('Usage Count')
    ax4.set_title('Operation Usage Statistics\n(This observer\'s preferences)')
    ax4.grid(axis='y', alpha=0.3)
    
    plt.suptitle('Observer Operation Switching: Dynamic Multi-Mode Usage',
                fontsize=16, weight='bold', y=0.95)
    
    plt.tight_layout()
    plt.savefig('/Users/cookie/zeckendorf-hilbert/docs/traditional-math/hilbert-complete/visualizations/tutorial/fig15_operation_switching.png',
                dpi=300, bbox_inches='tight')
    plt.close()
    
    print("✓ Figure 15 generated successfully")

if __name__ == "__main__":
    generate_figure_15()